name: Deploy to Azure Container Apps

on:
  push:
    branches:
      - release
  workflow_dispatch:

permissions:
  contents: read
  packages: write
  id-token: write

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Azure CLI
      run: |
        curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
        az version

    - name: Login to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Configure federated identity credentials for OIDC
      env:
        AZURE_CREDS: ${{ secrets.AZURE_CREDENTIALS }}
      run: |
        CLIENT_ID=$(echo "$AZURE_CREDS" | jq -r '.clientId')

        echo "Setting up federated credential for master branch..."
        az ad app federated-credential create \
          --id "$CLIENT_ID" \
          --parameters "{\"name\":\"github-actions-master\",\"issuer\":\"https://token.actions.githubusercontent.com\",\"subject\":\"repo:${{ github.repository }}:ref:refs/heads/master\",\"audiences\":[\"api://AzureADTokenExchange\"]}" \
          2>&1 | grep -v "already exists" || echo "Federated credential for master already exists or created"

        echo "Setting up federated credential for release branch..."
        az ad app federated-credential create \
          --id "$CLIENT_ID" \
          --parameters "{\"name\":\"github-actions-release\",\"issuer\":\"https://token.actions.githubusercontent.com\",\"subject\":\"repo:${{ github.repository }}:ref:refs/heads/release\",\"audiences\":[\"api://AzureADTokenExchange\"]}" \
          2>&1 | grep -v "already exists" || echo "Federated credential for release already exists or created"

        echo "✅ Federated identity credentials configured"

    - name: Extract subscription ID from Azure credentials
      env:
        AZURE_CREDS: ${{ secrets.AZURE_CREDENTIALS }}
      run: |
        SUBSCRIPTION_ID=$(echo "$AZURE_CREDS" | jq -r '.subscriptionId')
        echo "SUBSCRIPTION_ID=$SUBSCRIPTION_ID" >> $GITHUB_ENV

    - name: Extract parameters for resource group creation
      id: extract-params
      run: |
        NAME_PREFIX=$(jq -r '.parameters.namePrefix.value' infra/parameters.json)
        LOCATION=$(jq -r '.parameters.location.value' infra/parameters.json)

        # Validate required parameters
        if [ -z "$NAME_PREFIX" ] || [ "$NAME_PREFIX" = "null" ]; then
          echo "Error: namePrefix is required in parameters.json"
          exit 1
        fi
        if [ -z "$LOCATION" ] || [ "$LOCATION" = "null" ]; then
          echo "Error: location is required in parameters.json"
          exit 1
        fi

        REGISTRY_REPOSITORY=$(jq -r '.parameters.containerRegistryRepository.value // empty' infra/parameters.json 2>/dev/null)
        REGISTRY_SERVER=$(jq -r '.parameters.containerRegistryServer.value // empty' infra/parameters.json 2>/dev/null)
        if [ "$REGISTRY_REPOSITORY" = "null" ]; then
          REGISTRY_REPOSITORY=""
        fi
        if [ -z "$REGISTRY_REPOSITORY" ]; then
          REGISTRY_REPOSITORY="${GITHUB_REPOSITORY}"
          REGISTRY_REPOSITORY=$(echo "$REGISTRY_REPOSITORY" | tr '[:upper:]' '[:lower:]')
        fi
        if [ "$REGISTRY_SERVER" = "null" ] || [ -z "$REGISTRY_SERVER" ]; then
          REGISTRY_SERVER="ghcr.io"
        fi

        IMAGE_NAME="${NAME_PREFIX}-app"

        echo "name-prefix=$NAME_PREFIX" >> $GITHUB_OUTPUT
        echo "location=$LOCATION" >> $GITHUB_OUTPUT
        echo "resource-group=rg-${NAME_PREFIX}" >> $GITHUB_OUTPUT
        echo "container-registry-repository=$REGISTRY_REPOSITORY" >> $GITHUB_OUTPUT
        echo "container-registry-server=$REGISTRY_SERVER" >> $GITHUB_OUTPUT
        echo "image-name=$IMAGE_NAME" >> $GITHUB_OUTPUT

    - name: Create Resource Group
      run: |
        az group create \
          --name ${{ steps.extract-params.outputs.resource-group }} \
          --location ${{ steps.extract-params.outputs.location }}

    - name: Create secrets JSON from app secrets
      env:
        APP_SECRETS_JSON: ${{ secrets.APP_SECRETS }}
      run: |
        if [ -z "$APP_SECRETS_JSON" ]; then
          echo "Error: APP_SECRETS secret is not set"
          exit 1
        fi
        echo "$APP_SECRETS_JSON" > infra/secrets.json

        # Validate JSON structure
        if ! jq -e '.googleClientId' infra/secrets.json > /dev/null; then
          echo "Error: APP_SECRETS must contain 'googleClientId'"
          exit 1
        fi
        if ! jq -e '.googleClientSecret' infra/secrets.json > /dev/null; then
          echo "Error: APP_SECRETS must contain 'googleClientSecret'"
          exit 1
        fi
        if ! jq -e '.initialUserEmail' infra/secrets.json > /dev/null; then
          echo "Error: APP_SECRETS must contain 'initialUserEmail'"
          exit 1
        fi
        if ! jq -e '.mongoAdminPassword' infra/secrets.json > /dev/null; then
          echo "Error: APP_SECRETS must contain 'mongoAdminPassword'"
          exit 1
        fi
        if ! jq -e '.gitSettings.authorName' infra/secrets.json > /dev/null; then
          echo "Error: APP_SECRETS must contain 'gitSettings.authorName'"
          exit 1
        fi
        if ! jq -e '.gitSettings.authorEmail' infra/secrets.json > /dev/null; then
          echo "Error: APP_SECRETS must contain 'gitSettings.authorEmail'"
          exit 1
        fi
        if ! jq -e '.gitSettings.token' infra/secrets.json > /dev/null; then
          echo "Error: APP_SECRETS must contain 'gitSettings.token'"
          exit 1
        fi
        if ! jq -e '.gitSettings.cloneUrl' infra/secrets.json > /dev/null; then
          echo "Error: APP_SECRETS must contain 'gitSettings.cloneUrl'"
          exit 1
        fi
        echo "All required secrets validated"

    - name: Extract secrets for Bicep parameters
      id: extract-secrets
      env:
        APP_SECRETS_JSON: ${{ secrets.APP_SECRETS }}
      run: |
        echo "google-client-id=$(echo "$APP_SECRETS_JSON" | jq -r '.googleClientId')" >> $GITHUB_OUTPUT
        echo "google-client-secret=$(echo "$APP_SECRETS_JSON" | jq -r '.googleClientSecret')" >> $GITHUB_OUTPUT
        echo "initial-user-email=$(echo "$APP_SECRETS_JSON" | jq -r '.initialUserEmail')" >> $GITHUB_OUTPUT
        echo "mongo-admin-password=$(echo "$APP_SECRETS_JSON" | jq -r '.mongoAdminPassword')" >> $GITHUB_OUTPUT
        echo "git-author-name=$(echo "$APP_SECRETS_JSON" | jq -r '.gitSettings.authorName')" >> $GITHUB_OUTPUT
        echo "git-author-email=$(echo "$APP_SECRETS_JSON" | jq -r '.gitSettings.authorEmail')" >> $GITHUB_OUTPUT
        echo "git-token=$(echo "$APP_SECRETS_JSON" | jq -r '.gitSettings.token')" >> $GITHUB_OUTPUT
        echo "git-clone-url=$(echo "$APP_SECRETS_JSON" | jq -r '.gitSettings.cloneUrl')" >> $GITHUB_OUTPUT

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Cache Docker layers
      uses: actions/cache@v3
      with:
        path: /tmp/.buildx-cache
        key: ${{ runner.os }}-buildx-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-buildx-

    - name: Build Docker image
      run: |
        docker build -f FestivalManagementWeb/Dockerfile -t ${{ steps.extract-params.outputs.image-name }}:${{ github.sha }} .

    - name: Login to container registry
      run: |
        REGISTRY="${{ steps.extract-params.outputs.container-registry-server }}"
        if [ "$REGISTRY" = "ghcr.io" ]; then
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login "$REGISTRY" --username "${{ github.actor }}" --password-stdin
        else
          echo "Error: Only GHCR (ghcr.io) is supported as container registry"
          exit 1
        fi

    - name: Push Docker image
      run: |
        REPOSITORY="${{ steps.extract-params.outputs.container-registry-repository }}"
        REGISTRY="${{ steps.extract-params.outputs.container-registry-server }}"
        TARGET_IMAGE="$REGISTRY/$REPOSITORY"
        docker tag ${{ steps.extract-params.outputs.image-name }}:${{ github.sha }} $TARGET_IMAGE:${{ github.sha }}
        docker tag ${{ steps.extract-params.outputs.image-name }}:${{ github.sha }} $TARGET_IMAGE:latest
        docker push $TARGET_IMAGE:${{ github.sha }}
        docker push $TARGET_IMAGE:latest

    - name: Make package public (if GH_PAT configured)
      run: |
        if [ -z "${{ secrets.GH_PAT }}" ]; then
          echo "⚠️  GH_PAT secret not configured - skipping package visibility update"
          exit 0
        fi

        REPO_FULL="${{ steps.extract-params.outputs.container-registry-repository }}"
        OWNER=$(echo "$REPO_FULL" | cut -d'/' -f1)
        PACKAGE_NAME=$(echo "$REPO_FULL" | cut -d'/' -f2)

        echo "Setting package visibility to public..."

        # Try organization first, then user
        if curl -s -X PATCH \
          -H "Accept: application/vnd.github+json" \
          -H "Authorization: Bearer ${{ secrets.GH_PAT }}" \
          -H "X-GitHub-Api-Version: 2022-11-28" \
          "https://api.github.com/orgs/$OWNER/packages/container/$PACKAGE_NAME" \
          -d '{"visibility":"public"}' | grep -q '"visibility":"public"'; then
          echo "✅ Package set to public (organization)"
        elif curl -s -X PATCH \
          -H "Accept: application/vnd.github+json" \
          -H "Authorization: Bearer ${{ secrets.GH_PAT }}" \
          -H "X-GitHub-Api-Version: 2022-11-28" \
          "https://api.github.com/users/$OWNER/packages/container/$PACKAGE_NAME" \
          -d '{"visibility":"public"}' | grep -q '"visibility":"public"'; then
          echo "✅ Package set to public (user)"
        else
          echo "⚠️  Could not set package visibility automatically"
        fi

    - name: Deploy infrastructure (Cosmos DB + Environment)
      id: deploy-infrastructure
      run: |
        RESOURCE_GROUP="${{ steps.extract-params.outputs.resource-group }}"
        NAME_PREFIX="${{ steps.extract-params.outputs.name-prefix }}"
        ENV_NAME="${NAME_PREFIX}-env"
        COSMOS_NAME="${NAME_PREFIX}-cosmos"

        # Check if infrastructure already exists
        ENV_EXISTS=false
        COSMOS_EXISTS=false

        if az containerapp env show --name "$ENV_NAME" --resource-group "$RESOURCE_GROUP" &>/dev/null; then
          echo "Container Apps Environment already exists: $ENV_NAME"
          ENV_EXISTS=true
        fi

        if az cosmosdb mongocluster show --cluster-name "$COSMOS_NAME" --resource-group "$RESOURCE_GROUP" &>/dev/null 2>&1; then
          echo "Cosmos DB already exists: $COSMOS_NAME"
          COSMOS_EXISTS=true
        fi

        # Only deploy if something is missing
        if [ "$ENV_EXISTS" = false ] || [ "$COSMOS_EXISTS" = false ]; then
          echo "Deploying missing infrastructure..."
          az deployment group create \
            --name "infra-${{ github.run_number }}-${{ github.run_attempt }}" \
            --resource-group "$RESOURCE_GROUP" \
            --template-file infra/infrastructure.bicep \
            --parameters namePrefix="$NAME_PREFIX" \
            --parameters location="${{ steps.extract-params.outputs.location }}" \
            --parameters mongoAdminPassword="${{ steps.extract-secrets.outputs.mongo-admin-password }}" \
            --output json > infra-output.json

          ENV_ID=$(jq -r '.properties.outputs.environmentId.value' infra-output.json)
          COSMOS_NAME=$(jq -r '.properties.outputs.cosmosDbAccountName.value' infra-output.json)
        else
          echo "All infrastructure already exists, skipping deployment"
          ENV_ID=$(az containerapp env show --name "$ENV_NAME" --resource-group "$RESOURCE_GROUP" --query "id" -o tsv)
        fi

        echo "environmentId=$ENV_ID" >> $GITHUB_OUTPUT
        echo "cosmosDbAccountName=$COSMOS_NAME" >> $GITHUB_OUTPUT

    - name: Validate Container App template
      env:
        APP_NAME: ${{ steps.extract-params.outputs.image-name }}
        RESOURCE_GROUP: ${{ steps.extract-params.outputs.resource-group }}
        LOCATION: ${{ steps.extract-params.outputs.location }}
        CONTAINER_REGISTRY_SERVER: ${{ steps.extract-params.outputs.container-registry-server }}
        CONTAINER_REGISTRY_REPOSITORY: ${{ steps.extract-params.outputs.container-registry-repository }}
        ENVIRONMENT_ID: ${{ steps.deploy-infrastructure.outputs.environmentId }}
        COSMOS_NAME: ${{ steps.deploy-infrastructure.outputs.cosmosDbAccountName }}
        GOOGLE_CLIENT_ID: ${{ steps.extract-secrets.outputs.google-client-id }}
        GOOGLE_CLIENT_SECRET: ${{ steps.extract-secrets.outputs.google-client-secret }}
        INITIAL_USER_EMAIL: ${{ steps.extract-secrets.outputs.initial-user-email }}
        GIT_AUTHOR_NAME: ${{ steps.extract-secrets.outputs.git-author-name }}
        GIT_AUTHOR_EMAIL: ${{ steps.extract-secrets.outputs.git-author-email }}
        GIT_TOKEN: ${{ steps.extract-secrets.outputs.git-token }}
        GIT_CLONE_URL: ${{ steps.extract-secrets.outputs.git-clone-url }}
        MONGO_ADMIN_PASSWORD: ${{ steps.extract-secrets.outputs.mongo-admin-password }}
      run: |
        set -eo pipefail

        DEPLOYMENT_NAME="app-${{ github.run_number }}-${{ github.run_attempt }}"
        MONGO_CONN="mongodb+srv://mongoAdmin:${MONGO_ADMIN_PASSWORD}@${COSMOS_NAME}.mongocluster.cosmos.azure.com/?tls=true&authMechanism=SCRAM-SHA-256&retrywrites=false&maxIdleTimeMS=120000"

        VALIDATE_LOG=$(mktemp)
        if ! az deployment group validate \
          --name "$DEPLOYMENT_NAME" \
          --resource-group "$RESOURCE_GROUP" \
          --template-file infra/application.bicep \
          --parameters \
            containerAppName="$APP_NAME" \
            location="$LOCATION" \
            environmentId="$ENVIRONMENT_ID" \
            cosmosDbAccountName="$COSMOS_NAME" \
            imageTag="latest" \
            containerRegistryServer="$CONTAINER_REGISTRY_SERVER" \
            containerRegistryRepository="$CONTAINER_REGISTRY_REPOSITORY" \
            mongoConnectionString="$MONGO_CONN" \
            googleClientId="$GOOGLE_CLIENT_ID" \
            googleClientSecret="$GOOGLE_CLIENT_SECRET" \
            initialUserEmail="$INITIAL_USER_EMAIL" \
            gitAuthorName="$GIT_AUTHOR_NAME" \
            gitAuthorEmail="$GIT_AUTHOR_EMAIL" \
            gitToken="$GIT_TOKEN" \
            gitCloneUrl="$GIT_CLONE_URL" \
          > "$VALIDATE_LOG" 2>&1; then
          if grep -qi "The content for this response was already consumed" "$VALIDATE_LOG"; then
            echo "::warning::Azure CLI validation returned a known bug (response already consumed). Proceeding to deployment; see deployment step for concrete errors."
          else
            echo "::group::Container App validation failure"
            cat "$VALIDATE_LOG"
            echo "::endgroup::"
            rm -f "$VALIDATE_LOG"
            exit 1
          fi
        fi
        rm -f "$VALIDATE_LOG"

    - name: Deploy Container App configuration
      id: deploy-application
      env:
        APP_NAME: ${{ steps.extract-params.outputs.image-name }}
        RESOURCE_GROUP: ${{ steps.extract-params.outputs.resource-group }}
        LOCATION: ${{ steps.extract-params.outputs.location }}
        CONTAINER_REGISTRY_SERVER: ${{ steps.extract-params.outputs.container-registry-server }}
        CONTAINER_REGISTRY_REPOSITORY: ${{ steps.extract-params.outputs.container-registry-repository }}
        ENVIRONMENT_ID: ${{ steps.deploy-infrastructure.outputs.environmentId }}
        COSMOS_NAME: ${{ steps.deploy-infrastructure.outputs.cosmosDbAccountName }}
        GOOGLE_CLIENT_ID: ${{ steps.extract-secrets.outputs.google-client-id }}
        GOOGLE_CLIENT_SECRET: ${{ steps.extract-secrets.outputs.google-client-secret }}
        INITIAL_USER_EMAIL: ${{ steps.extract-secrets.outputs.initial-user-email }}
        GIT_AUTHOR_NAME: ${{ steps.extract-secrets.outputs.git-author-name }}
        GIT_AUTHOR_EMAIL: ${{ steps.extract-secrets.outputs.git-author-email }}
        GIT_TOKEN: ${{ steps.extract-secrets.outputs.git-token }}
        GIT_CLONE_URL: ${{ steps.extract-secrets.outputs.git-clone-url }}
        MONGO_ADMIN_PASSWORD: ${{ steps.extract-secrets.outputs.mongo-admin-password }}
      run: |
        set -eo pipefail

        DEPLOYMENT_NAME="app-${{ github.run_number }}-${{ github.run_attempt }}"
        IMAGE_TAG="latest"
        MONGO_CONN="mongodb+srv://mongoAdmin:${MONGO_ADMIN_PASSWORD}@${COSMOS_NAME}.mongocluster.cosmos.azure.com/?tls=true&authMechanism=SCRAM-SHA-256&retrywrites=false&maxIdleTimeMS=120000"
        IMAGE_REF="${CONTAINER_REGISTRY_SERVER}/${CONTAINER_REGISTRY_REPOSITORY}:${IMAGE_TAG}"

        APP_EXISTS=false
        if az containerapp show --name "$APP_NAME" --resource-group "$RESOURCE_GROUP" &>/dev/null; then
          APP_EXISTS=true
        fi

        if [ "$APP_EXISTS" = false ]; then
          CREATE_LOG=$(mktemp)
          if ! az containerapp create \
            --name "$APP_NAME" \
            --resource-group "$RESOURCE_GROUP" \
            --environment "$ENVIRONMENT_ID" \
            --image "$IMAGE_REF" \
            --ingress external \
            --target-port 8080 \
            --transport auto \
            --min-replicas 0 \
            --max-replicas 1 \
            --cpu 0.25 \
            --memory 0.5Gi \
            --secrets \
              mongo-connection-string="$MONGO_CONN" \
              google-client-id="$GOOGLE_CLIENT_ID" \
              google-client-secret="$GOOGLE_CLIENT_SECRET" \
              git-token="$GIT_TOKEN" \
              git-clone-url="$GIT_CLONE_URL" \
            --env-vars \
              ASPNETCORE_ENVIRONMENT=Production \
              MongoDbSettings__ConnectionString=secretref:mongo-connection-string \
              MongoDbSettings__DatabaseName=FestivalManagement \
              Authentication__Google__ClientId=secretref:google-client-id \
              Authentication__Google__ClientSecret=secretref:google-client-secret \
              InitialUser__Email="$INITIAL_USER_EMAIL" \
              FreeTier__EnableBanner=true \
              FreeTier__BudgetVcpuSeconds=180000 \
              FreeTier__BudgetGiBSeconds=360000 \
              FreeTier__Resource__VcpuPerReplica=0.25 \
              FreeTier__Resource__MemoryGiBPerReplica=0.5 \
              FreeTier__Resource__ReplicaFactor=1 \
              AzureUsage__Enabled=true \
              AzureUsage__ContainerAppName="$APP_NAME" \
              AzureUsage__ResourceGroup="$RESOURCE_GROUP" \
              AzureUsage__SubscriptionId="${{ env.SUBSCRIPTION_ID }}" \
              AzureUsage__MetricsRefreshMinutes=10 \
              AzureUsage__CostRefreshMinutes=360 \
              FreeTier__Cosmos__Enabled=true \
              FreeTier__Cosmos__SubscriptionId="${{ env.SUBSCRIPTION_ID }}" \
              FreeTier__Cosmos__ResourceGroup="$RESOURCE_GROUP" \
              FreeTier__Cosmos__AccountName="$COSMOS_NAME" \
              FreeTier__Cosmos__DatabaseName=FestivalManagement \
              FreeTier__Cosmos__AccountResourceId="/subscriptions/${{ env.SUBSCRIPTION_ID }}/resourceGroups/$RESOURCE_GROUP/providers/Microsoft.DocumentDB/mongoClusters/$COSMOS_NAME" \
              FreeTier__EnforceRequestDailyCap=false \
              FreeTier__Data__BudgetGb=100 \
              FreeTier__Requests__Budget=2000000 \
              FreeTier__Cosmos__Provisioning=vCore \
              FreeTier__Cosmos__FreeTierStorageGb=32 \
              FreeTier__Cosmos__FreeTierVCoreStorageGb=32 \
              FreeTier__Cosmos__WarnRuPercent=90 \
              FreeTier__Cosmos__WarnStoragePercent=90 \
              FreeTier__Cosmos__RefreshMinutes=60 \
              GitSettings__RemoteName=origin \
              FreeTier__Cosmos__CollectionNames__0=TextKeyValues \
              FreeTier__Cosmos__CollectionNames__1=ImageKeyValues \
              GitSettings__AuthorName="$GIT_AUTHOR_NAME" \
              GitSettings__AuthorEmail="$GIT_AUTHOR_EMAIL" \
              GitSettings__Token=secretref:git-token \
              GitSettings__CloneUrl=secretref:git-clone-url \
            > "$CREATE_LOG" 2>&1; then
            echo "::group::Container App creation failure"
            cat "$CREATE_LOG"
            echo "::endgroup::"
            rm -f "$CREATE_LOG"
            exit 1
          fi
          rm -f "$CREATE_LOG"
        else
          UPDATE_LOG=$(mktemp)
          if ! az containerapp update \
            --name "$APP_NAME" \
            --resource-group "$RESOURCE_GROUP" \
            --image "$IMAGE_REF" \
            > "$UPDATE_LOG" 2>&1; then
            echo "::group::Container App image update failure"
            cat "$UPDATE_LOG"
            echo "::endgroup::"
            rm -f "$UPDATE_LOG"
            exit 1
          fi
          rm -f "$UPDATE_LOG"
        fi

        SECRET_LOG=$(mktemp)
        if ! az containerapp secret set \
          --name "$APP_NAME" \
          --resource-group "$RESOURCE_GROUP" \
          --secrets \
            mongo-connection-string="$MONGO_CONN" \
            google-client-id="$GOOGLE_CLIENT_ID" \
            google-client-secret="$GOOGLE_CLIENT_SECRET" \
            git-token="$GIT_TOKEN" \
            git-clone-url="$GIT_CLONE_URL" \
          > "$SECRET_LOG" 2>&1; then
          echo "::group::Container App secret update failure"
          cat "$SECRET_LOG"
          echo "::endgroup::"
          rm -f "$SECRET_LOG"
          exit 1
        fi
        rm -f "$SECRET_LOG"

        ENV_LOG=$(mktemp)
        if ! az containerapp update \
          --name "$APP_NAME" \
          --resource-group "$RESOURCE_GROUP" \
          --set-env-vars \
            ASPNETCORE_ENVIRONMENT=Production \
            MongoDbSettings__ConnectionString=secretref:mongo-connection-string \
            MongoDbSettings__DatabaseName=FestivalManagement \
            Authentication__Google__ClientId=secretref:google-client-id \
            Authentication__Google__ClientSecret=secretref:google-client-secret \
            InitialUser__Email="$INITIAL_USER_EMAIL" \
            FreeTier__EnableBanner=true \
            FreeTier__BudgetVcpuSeconds=180000 \
            FreeTier__BudgetGiBSeconds=360000 \
            FreeTier__Resource__VcpuPerReplica=0.25 \
            FreeTier__Resource__MemoryGiBPerReplica=0.5 \
            FreeTier__Resource__ReplicaFactor=1 \
            AzureUsage__Enabled=true \
            AzureUsage__ContainerAppName="$APP_NAME" \
            AzureUsage__ResourceGroup="$RESOURCE_GROUP" \
            AzureUsage__SubscriptionId="${{ env.SUBSCRIPTION_ID }}" \
            AzureUsage__MetricsRefreshMinutes=10 \
            AzureUsage__CostRefreshMinutes=360 \
            FreeTier__Cosmos__Enabled=true \
            FreeTier__Cosmos__SubscriptionId="${{ env.SUBSCRIPTION_ID }}" \
            FreeTier__Cosmos__ResourceGroup="$RESOURCE_GROUP" \
            FreeTier__Cosmos__AccountName="$COSMOS_NAME" \
            FreeTier__Cosmos__DatabaseName=FestivalManagement \
            FreeTier__Cosmos__AccountResourceId="/subscriptions/${{ env.SUBSCRIPTION_ID }}/resourceGroups/$RESOURCE_GROUP/providers/Microsoft.DocumentDB/mongoClusters/$COSMOS_NAME" \
            FreeTier__EnforceRequestDailyCap=false \
            FreeTier__Data__BudgetGb=100 \
            FreeTier__Requests__Budget=2000000 \
            FreeTier__Cosmos__Provisioning=vCore \
            FreeTier__Cosmos__FreeTierStorageGb=32 \
            FreeTier__Cosmos__FreeTierVCoreStorageGb=32 \
            FreeTier__Cosmos__WarnRuPercent=90 \
            FreeTier__Cosmos__WarnStoragePercent=90 \
            FreeTier__Cosmos__RefreshMinutes=60 \
            GitSettings__RemoteName=origin \
            FreeTier__Cosmos__CollectionNames__0=TextKeyValues \
            FreeTier__Cosmos__CollectionNames__1=ImageKeyValues \
            GitSettings__AuthorName="$GIT_AUTHOR_NAME" \
            GitSettings__AuthorEmail="$GIT_AUTHOR_EMAIL" \
            GitSettings__Token=secretref:git-token \
            GitSettings__CloneUrl=secretref:git-clone-url \
          > "$ENV_LOG" 2>&1; then
          echo "::group::Container App env update failure"
          cat "$ENV_LOG"
          echo "::endgroup::"
          rm -f "$ENV_LOG"
          exit 1
        fi
        rm -f "$ENV_LOG"

        APP_URL=$(az containerapp show --name "$APP_NAME" --resource-group "$RESOURCE_GROUP" --query "properties.configuration.ingress.fqdn" -o tsv)
        PRINCIPAL_ID=$(az containerapp show --name "$APP_NAME" --resource-group "$RESOURCE_GROUP" --query "identity.principalId" -o tsv)

        echo "containerAppUrl=https://$APP_URL" >> "$GITHUB_OUTPUT"
        echo "containerAppPrincipalId=$PRINCIPAL_ID" >> "$GITHUB_OUTPUT"

    - name: Assign roles to Container App managed identity
      continue-on-error: true
      run: |
        PRINCIPAL_ID="${{ steps.deploy-application.outputs.containerAppPrincipalId }}"
        RESOURCE_GROUP="${{ steps.extract-params.outputs.resource-group }}"

        if [ -z "$PRINCIPAL_ID" ] || [ "$PRINCIPAL_ID" = "null" ]; then
          echo "Warning: Principal ID not found, skipping role assignments"
          exit 0
        fi

        echo "Waiting for managed identity to propagate..."
        sleep 30

        echo "Assigning Reader role..."
        az role assignment create \
          --assignee "$PRINCIPAL_ID" \
          --role "Reader" \
          --scope "/subscriptions/${{ env.SUBSCRIPTION_ID }}/resourceGroups/$RESOURCE_GROUP" \
          2>&1 | grep -v "already exists" || true

        echo "Assigning Monitoring Reader role..."
        az role assignment create \
          --assignee "$PRINCIPAL_ID" \
          --role "Monitoring Reader" \
          --scope "/subscriptions/${{ env.SUBSCRIPTION_ID }}/resourceGroups/$RESOURCE_GROUP" \
          2>&1 | grep -v "already exists" || true

        echo "Assigning Cost Management Reader role..."
        az role assignment create \
          --assignee "$PRINCIPAL_ID" \
          --role "Cost Management Reader" \
          --scope "/subscriptions/${{ env.SUBSCRIPTION_ID }}" \
          2>&1 | grep -v "already exists" || true

        echo "Role assignments completed"

    - name: Cleanup secrets
      if: always()
      run: rm -f infra/secrets.json

    - name: Output application URL
      run: |
        echo "Application deployed to: ${{ steps.deploy-application.outputs.containerAppUrl }}"

