name: Usage Guardian (Free)

on:
  workflow_dispatch:
permissions:
  id-token: write
  contents: read

concurrency:
  group: usage-guardian
  cancel-in-progress: true

env:
  SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

  TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

  CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}

  RESOURCE_GROUP: ${{ vars.CA_RESOURCE_GROUP }}

  APP_NAME: ${{ vars.CA_APP_NAME }}

  # Budgets (override via repo/org variables if desired)

  BUDGET_VCPU_SECONDS: 180000

  BUDGET_GIB_SECONDS: 360000

  BUDGET_REQUESTS: 2000000

  BUDGET_DATA_GB: 100

  WARN_PCT: 95

  STOP_PCT: 100

  # Actual cost (currency) thresholds
  STOP_ON_ACTUAL_COST: true
  COST_STOP_THRESHOLD: 0       # Stop when cost (month-to-date) exceeds this amount
  COST_WARN_THRESHOLD: ""      # Optional warn threshold; leave blank to disable

  # Optional: stop if remaining monthly budget <= this percent (any meter)

  REMAIN_STOP_PCT: ""   # e.g., 10 (stop when remaining <=10%)

  REMAIN_WARN_PCT: ""   # e.g., 20 (warn when remaining <=20%)

    COSMOS_ACCOUNT_NAME: ${{ vars.COSMOS_ACCOUNT_NAME }}

  COSMOS_RESOURCE_GROUP: ${{ vars.COSMOS_RESOURCE_GROUP }}

  COSMOS_SUBSCRIPTION_ID: ${{ vars.COSMOS_SUBSCRIPTION_ID }}

  COSMOS_DATABASE_NAME: ${{ vars.COSMOS_DATABASE_NAME }}

  COSMOS_COLLECTION_NAMES: ${{ vars.COSMOS_COLLECTION_NAMES }}

  COSMOS_PROVISIONING: ${{ vars.COSMOS_PROVISIONING }}

  COSMOS_FREE_RU_LIMIT: 1000

  COSMOS_FREE_STORAGE_GB: 25

  COSMOS_WARN_RU_PCT: 95

  COSMOS_STOP_RU_PCT: 100

  COSMOS_WARN_STORAGE_PCT: 95

  COSMOS_STOP_STORAGE_PCT: 100
\njobs:

  guard:

    runs-on: ubuntu-latest

    steps:

      - name: Azure Login (OIDC)

        uses: azure/login@v2

        with:

          client-id: ${{ env.CLIENT_ID }}

          tenant-id: ${{ env.TENANT_ID }}

          subscription-id: ${{ env.SUBSCRIPTION_ID }}



      - name: Ensure containerapp extension
        shell: bash
        run: |
          az config set extension.use_dynamic_install=yes_without_prompt
          if ! az extension show --name containerapp >/dev/null 2>&1; then
            az extension add --name containerapp
          fi

      - name: Check usage and freeze if needed

        shell: bash

        run: |

          set -euo pipefail

          if [[ -z "$RESOURCE_GROUP" || -z "$APP_NAME" ]]; then

            echo "Set CA_RESOURCE_GROUP and CA_APP_NAME as repo variables." >&2

            exit 1

          fi



          RID=$(az containerapp show -n "$APP_NAME" -g "$RESOURCE_GROUP" --query id -o tsv)

          if [[ -z "$RID" ]]; then echo "Container App not found" >&2; exit 1; fi



          COSMOS_ACCOUNT="${COSMOS_ACCOUNT_NAME:-}"
          COSMOS_RG="${COSMOS_RESOURCE_GROUP:-$RESOURCE_GROUP}"
          COSMOS_SUB="${COSMOS_SUBSCRIPTION_ID:-$SUBSCRIPTION_ID}"
          COSMOS_DB="${COSMOS_DATABASE_NAME:-}"
          COSMOS_COLLECTIONS="${COSMOS_COLLECTION_NAMES:-}"
          COSMOS_PROVISIONING="${COSMOS_PROVISIONING:-RequestUnits}"
          COSMOS_FREE_RU="${COSMOS_FREE_RU_LIMIT:-1000}"
          COSMOS_FREE_STORAGE="${COSMOS_FREE_STORAGE_GB:-25}"
          COSMOS_WARN_RU="${COSMOS_WARN_RU_PCT:-$WARN_PCT}"
          COSMOS_STOP_RU="${COSMOS_STOP_RU_PCT:-$STOP_PCT}"
          COSMOS_WARN_STORAGE="${COSMOS_WARN_STORAGE_PCT:-$WARN_PCT}"
          COSMOS_STOP_STORAGE="${COSMOS_STOP_STORAGE_PCT:-$STOP_PCT}"
          COST_WARN_THRESHOLD="${COST_WARN_THRESHOLD:-}"
          COST_STOP_THRESHOLD="${COST_STOP_THRESHOLD:-0}"
          STOP_ON_ACTUAL_COST="${STOP_ON_ACTUAL_COST:-true}"
          # Month window

          START="$(date -u +%Y-%m-01T00:00:00Z)"

          END="$(date -u +%Y-%m-%dT%H:%M:%SZ)"



          # Metrics: Requests, TxBytes

          METRICS_JSON=$(az monitor metrics list --resource "$RID" \

            --metric Requests TxBytes --aggregation Total --interval PT1H \

            --start-time "$START" --end-time "$END" -o json)



          sum_metric() {

            local name=$1

            echo "$METRICS_JSON" | jq -r \

              --arg n "$name" \

              '.value[] | select(.name.value==$n) | .timeseries[]? | .data[]? | .total // 0' | awk '{s+=$1} END {printf "%.0f", s}'

          }



          REQ_USED=$(sum_metric Requests)

          TX_BYTES=$(sum_metric TxBytes)



          # Cost Management: vCPU-seconds & GiB-seconds

          COST_BODY=$(jq -n --arg start "$START" --arg end "$END" --arg rid "$RID" --arg rg "$RESOURCE_GROUP" '{

            type:"Usage", timeframe:"Custom", timePeriod:{from:$start,to:$end},

            dataset:{granularity:"None", aggregation:{totalCost:{name:"PreTaxCost",function:"Sum"}},

                     grouping:[{type:"Dimension",name:"Meter"},{type:"Dimension",name:"ServiceName"}],

                     filter:{ and: [

                       { dimensions:{ name:"ServiceName", operator:"In", values:["Azure Container Apps"] } },

                       (if $rid != ""

                           then { dimensions:{ name:"ResourceId", operator:"In", values:[$rid] } }

                           else { dimensions:{ name:"ResourceGroupName", operator:"In", values:[$rg] } }

                       end)

                     ]}}

          }')



          COST_AVAILABLE=1
          COST_JSON=""
          if ! COST_JSON=$(az rest --method post --url "https://management.azure.com/subscriptions/$SUBSCRIPTION_ID/providers/Microsoft.CostManagement/query?api-version=2024-07-01" --headers Content-Type=application/json --body "$COST_BODY"); then
            status=$?
            COST_AVAILABLE=0
            echo "Warning: Cost Management query failed (exit $status). Skipping CPU/MEM cost checks." >&2
          fi

          TOTAL_COST="0.0000"
          COST_CURRENCY=""
          if [[ $COST_AVAILABLE -eq 1 ]]; then
            VCPU_S=$(echo "$COST_JSON" | jq '[.properties.rows[] | map(tostring)] | map(select(any(.[]; test("vCPU";"i")))) | map(map(tonumber?)) | flatten | max // 0')
            GIB_S=$(echo "$COST_JSON" | jq '[.properties.rows[] | map(tostring)] | map(select(any(.[]; test("GiB";"i")))) | map(map(tonumber?)) | flatten | max // 0')
            TOTAL_COST_RAW=$(echo "$COST_JSON" | jq '[.properties.rows[] | [ .[] | tonumber? ] | add // 0] | add // 0')
            if [[ -z "$TOTAL_COST_RAW" ]]; then
              TOTAL_COST_RAW=0
            fi
            TOTAL_COST=$(printf '%.4f' "$TOTAL_COST_RAW")
            COST_CURRENCY=$(echo "$COST_JSON" | jq -r '[.properties.rows[] | .[] | select(type=="string" and test("^[A-Z]{3}$"))][0] // empty')
          else
            VCPU_S=0
            GIB_S=0
          fi


          # Projection

          DAY=$(date -u +%d | sed 's/^0*//')

          DAYS_IN_MONTH=$(cal $(date -u +%m) $(date -u +%Y) | awk 'NF{D=$NF} END{print D}')

          REM_DAYS=$((DAYS_IN_MONTH - DAY + 1))

          [[ $REM_DAYS -lt 1 ]] && REM_DAYS=1



          proj_pct() {

            local used=$1 budget=$2

            if (( $(echo "$budget <= 0" | bc -l) )); then echo 0; return; fi

            local day_count=${DAY:-1}
            if ! [[ $day_count =~ ^[0-9]+$ ]]; then
              day_count=1
            elif (( day_count <= 0 )); then
              day_count=1
            fi
            local daily=$(echo "$used / $day_count" | bc -l)

            local projected=$(echo "$used + ($daily * $REM_DAYS)" | bc -l)

            echo $(printf '%.2f' $(echo "100 * $projected / $budget" | bc -l))

          }



          CPU_P=$(proj_pct "$VCPU_S" "$BUDGET_VCPU_SECONDS")

          MEM_P=$(proj_pct "$GIB_S" "$BUDGET_GIB_SECONDS")

          REQ_P=$(proj_pct "$REQ_USED" "$BUDGET_REQUESTS")

          DATA_GB=$(printf '%.3f' $(echo "$TX_BYTES / 1e9" | bc -l))

          DATA_P=$(proj_pct "$DATA_GB" "$BUDGET_DATA_GB")



          echo "Proj% CPU=$CPU_P MEM=$MEM_P REQ=$REQ_P DATA=$DATA_P (remDays=$REM_DAYS)"



          exceed() { awk -v a=$1 -v b=$2 'BEGIN{exit !(a>=b)}'; }

          beloweq() { awk -v a=$1 -v b=$2 'BEGIN{exit !(a<=b)}'; }

          greater() { awk -v a=$1 -v b=$2 'BEGIN{exit !(a>b)}'; }



          # Remaining percentages (month-to-date, not projected)

          pct_or_zero() {

            local used=$1 budget=$2

            if (( $(echo "$budget <= 0" | bc -l) )); then echo 0; return; fi

            local p=$(echo "100 * $used / $budget" | bc -l)

            # clamp [0,100]

            if (( $(echo "$p < 0" | bc -l) )); then p=0; fi

            if (( $(echo "$p > 100" | bc -l) )); then p=100; fi

            printf '%.2f' "$p"

          }



          CPU_USED_PCT=$(pct_or_zero "$VCPU_S" "$BUDGET_VCPU_SECONDS")

          MEM_USED_PCT=$(pct_or_zero "$GIB_S" "$BUDGET_GIB_SECONDS")

          REQ_USED_PCT=$(pct_or_zero "$REQ_USED" "$BUDGET_REQUESTS")

          DATA_USED_PCT=$(pct_or_zero "$DATA_GB" "$BUDGET_DATA_GB")

          CPU_REM_PCT=$(printf '%.2f' $(echo "100 - $CPU_USED_PCT" | bc -l))

          MEM_REM_PCT=$(printf '%.2f' $(echo "100 - $MEM_USED_PCT" | bc -l))

          REQ_REM_PCT=$(printf '%.2f' $(echo "100 - $REQ_USED_PCT" | bc -l))

          DATA_REM_PCT=$(printf '%.2f' $(echo "100 - $DATA_USED_PCT" | bc -l))

          echo "Remain% CPU=$CPU_REM_PCT MEM=$MEM_REM_PCT REQ=$REQ_REM_PCT DATA=$DATA_REM_PCT"

          COST_LABEL="$TOTAL_COST"
          if [[ -n "$COST_CURRENCY" ]]; then
            COST_LABEL="$COST_LABEL $COST_CURRENCY"
          fi

          if [[ $COST_AVAILABLE -eq 1 ]]; then
            echo "Cost MTD (PreTaxCost): $COST_LABEL"
          else
            echo "Cost MTD (PreTaxCost): unavailable"
          fi

          SHOULD_STOP=0

          SHOULD_WARN=0

          COST_SHOULD_STOP=0
          COST_SHOULD_WARN=0
          COST_TRIGGER_MESSAGE=""

          if [[ $COST_AVAILABLE -eq 1 ]]; then
            cost_stop_val="${COST_STOP_THRESHOLD:-0}"
            cost_warn_val="$COST_WARN_THRESHOLD"
            if [[ "${STOP_ON_ACTUAL_COST,,}" == "true" ]]; then
              if greater "$TOTAL_COST" "$cost_stop_val"; then
                COST_SHOULD_STOP=1
                COST_TRIGGER_MESSAGE="Actual cost $COST_LABEL exceeded stop threshold ${cost_stop_val}"
              fi
            fi
            if [[ $COST_SHOULD_STOP -ne 1 && -n "$cost_warn_val" ]]; then
              if greater "$TOTAL_COST" "$cost_warn_val"; then
                COST_SHOULD_WARN=1
                COST_TRIGGER_MESSAGE="Actual cost $COST_LABEL exceeded warn threshold ${cost_warn_val}"
              fi
            fi
          fi

          if [[ $COST_SHOULD_STOP -eq 1 ]]; then
            SHOULD_STOP=1
            echo "$COST_TRIGGER_MESSAGE"
          elif [[ $COST_SHOULD_WARN -eq 1 ]]; then
            SHOULD_WARN=1
            echo "$COST_TRIGGER_MESSAGE"
          fi



          # Stop based on projected used percent

          if exceed "$CPU_P" "$STOP_PCT" || exceed "$MEM_P" "$STOP_PCT" || exceed "$REQ_P" "$STOP_PCT" || exceed "$DATA_P" "$STOP_PCT"; then

            SHOULD_STOP=1

          fi



          # Stop based on remaining monthly percent (if configured)

          if [[ -n "$REMAIN_STOP_PCT" ]]; then

            if beloweq "$CPU_REM_PCT" "$REMAIN_STOP_PCT" || beloweq "$MEM_REM_PCT" "$REMAIN_STOP_PCT" || beloweq "$REQ_REM_PCT" "$REMAIN_STOP_PCT" || beloweq "$DATA_REM_PCT" "$REMAIN_STOP_PCT"; then

              SHOULD_STOP=1

            fi

          fi



          # Warn checks

          if exceed "$CPU_P" "$WARN_PCT" || exceed "$MEM_P" "$WARN_PCT" || exceed "$REQ_P" "$WARN_PCT" || exceed "$DATA_P" "$WARN_PCT"; then

            SHOULD_WARN=1

          fi

          if [[ -n "$REMAIN_WARN_PCT" ]]; then

            if beloweq "$CPU_REM_PCT" "$REMAIN_WARN_PCT" || beloweq "$MEM_REM_PCT" "$REMAIN_WARN_PCT" || beloweq "$REQ_REM_PCT" "$REMAIN_WARN_PCT" || beloweq "$DATA_REM_PCT" "$REMAIN_WARN_PCT"; then

              SHOULD_WARN=1

            fi

          fi



          COSMOS_SHOULD_WARN=0
          COSMOS_SHOULD_STOP=0

          if [[ -n "$COSMOS_ACCOUNT" ]]; then
            echo "Checking Cosmos DB free-tier status for account $COSMOS_ACCOUNT"
            ACCOUNT_JSON=$(az cosmosdb show -n "$COSMOS_ACCOUNT" -g "$COSMOS_RG" --subscription "$COSMOS_SUB" -o json 2>/dev/null || echo '')
            if [[ -z "$ACCOUNT_JSON" ]]; then
              echo "Unable to retrieve Cosmos DB account metadata." >&2
              COSMOS_SHOULD_WARN=1
            else
              FREE_TIER_FLAG=$(echo "$ACCOUNT_JSON" | jq -r '.properties.enableFreeTier // .properties.isFreeTierAccount // empty')
              KIND=$(echo "$ACCOUNT_JSON" | jq -r '.kind // empty')
              ACCOUNT_ID=$(echo "$ACCOUNT_JSON" | jq -r '.id // empty')
              if [[ "$FREE_TIER_FLAG" != "true" ]]; then
                echo "Cosmos DB free tier is not active on this account." >&2
                COSMOS_SHOULD_WARN=1
              fi
              if [[ "$KIND" != *"Mongo"* ]]; then
                echo "Cosmos DB account is not configured for the MongoDB API (kind=$KIND)." >&2
                COSMOS_SHOULD_WARN=1
              fi

              COSMOS_RU_TOTAL=0
              if [[ "${COSMOS_PROVISIONING,,}" == "requestunits" && -n "$COSMOS_DB" ]]; then
                DB_THROUGHPUT=$(az cosmosdb mongodb database throughput show -a "$COSMOS_ACCOUNT" -g "$COSMOS_RG" -n "$COSMOS_DB" --subscription "$COSMOS_SUB" --query resource.throughput -o tsv 2>/dev/null || true)
                if [[ -n "$DB_THROUGHPUT" ]]; then
                  echo "Cosmos shared throughput: ${DB_THROUGHPUT} RU/s"
                  COSMOS_RU_TOTAL=$((COSMOS_RU_TOTAL + DB_THROUGHPUT))
                fi

                collection_source="$COSMOS_COLLECTIONS"
                if [[ -z "$collection_source" ]]; then
                  collection_source=$(az cosmosdb mongodb collection list -a "$COSMOS_ACCOUNT" -g "$COSMOS_RG" -d "$COSMOS_DB" --subscription "$COSMOS_SUB" --query '[].name' -o tsv 2>/dev/null | tr '\n' ',' | sed 's/,$//')
                fi

                IFS=',' read -r -a collection_list <<< "$collection_source"
                for coll in "${collection_list[@]}"; do
                  coll=$(echo "$coll" | xargs)
                  [[ -z "$coll" ]] && continue
                  THRU=$(az cosmosdb mongodb collection throughput show -a "$COSMOS_ACCOUNT" -g "$COSMOS_RG" -d "$COSMOS_DB" -n "$coll" --subscription "$COSMOS_SUB" --query resource.throughput -o tsv 2>/dev/null || true)
                  if [[ -n "$THRU" ]]; then
                    echo "Cosmos dedicated throughput: $coll -> ${THRU} RU/s"
                    COSMOS_RU_TOTAL=$((COSMOS_RU_TOTAL + THRU))
                  fi
                done

                if (( COSMOS_RU_TOTAL > 0 )); then
                  if (( $(echo "${COSMOS_FREE_RU} > 0" | bc -l 2>/dev/null || echo 0) )); then
                    COSMOS_RU_PCT=$(echo "scale=2; 100 * $COSMOS_RU_TOTAL / ${COSMOS_FREE_RU}" | bc 2>/dev/null || echo 0)
                    echo "Cosmos RU usage: ${COSMOS_RU_TOTAL} RU/s of ${COSMOS_FREE_RU} (${COSMOS_RU_PCT}% used)"
                    if exceed "$COSMOS_RU_PCT" "$COSMOS_STOP_RU"; then
                      COSMOS_SHOULD_STOP=1
                    elif exceed "$COSMOS_RU_PCT" "$COSMOS_WARN_RU"; then
                      COSMOS_SHOULD_WARN=1
                    fi
                  fi
                fi
              fi

              if [[ -n "$ACCOUNT_ID" ]]; then
                STORAGE_BYTES=$(az monitor metrics list --resource "$ACCOUNT_ID" --subscription "$COSMOS_SUB" --metric TotalAccountStorage --aggregation Maximum --interval PT1H --start-time "$(date -u -d '6 hours ago' +%Y-%m-%dT%H:%M:%SZ)" --end-time "$END" --metric-namespace microsoft.documentdb/databaseaccounts --query 'value[0].timeseries[0].data[-1].maximum' -o tsv 2>/dev/null || echo '')
                if [[ -n "$STORAGE_BYTES" && "$STORAGE_BYTES" != "null" ]]; then
                  COSMOS_STORAGE_GB=$(echo "scale=3; $STORAGE_BYTES / 1073741824" | bc 2>/dev/null || echo 0)
                  echo "Cosmos storage: ${COSMOS_STORAGE_GB} GB of ${COSMOS_FREE_STORAGE}"
                  if (( $(echo "${COSMOS_FREE_STORAGE} > 0" | bc -l 2>/dev/null || echo 0) )); then
                    COSMOS_STORAGE_PCT=$(echo "scale=2; 100 * $COSMOS_STORAGE_GB / ${COSMOS_FREE_STORAGE}" | bc 2>/dev/null || echo 0)
                    if exceed "$COSMOS_STORAGE_PCT" "$COSMOS_STOP_STORAGE"; then
                      COSMOS_SHOULD_STOP=1
                    elif exceed "$COSMOS_STORAGE_PCT" "$COSMOS_WARN_STORAGE"; then
                      COSMOS_SHOULD_WARN=1
                    fi
                  fi
                fi
              fi
            fi

            if [[ "$COSMOS_SHOULD_STOP" == "1" ]]; then
              SHOULD_STOP=1
            elif [[ "$COSMOS_SHOULD_WARN" == "1" ]]; then
              SHOULD_WARN=1
            fi
          fi
          if [[ "$SHOULD_STOP" == "1" ]]; then

            echo "Threshold reached: freezing Container App"

            az containerapp update -n "$APP_NAME" -g "$RESOURCE_GROUP" --min-replicas 0 --max-replicas 0

            if [[ "$DISABLE_INGRESS_ON_STOP" == "true" ]]; then

              az containerapp ingress disable -n "$APP_NAME" -g "$RESOURCE_GROUP"

            fi

          elif [[ "$SHOULD_WARN" == "1" ]]; then

            echo "Warning threshold reached. No action taken."

          else

            echo "Within limits."

          fi











